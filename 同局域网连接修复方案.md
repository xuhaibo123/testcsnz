# 同局域网连接修复方案

## 问题描述

当两个客户端在同一个局域网（NAT）下时，无法加入对方创建的游戏房间。

### 场景说明

- **服务器**: 公网IP `119.91.238.117`
- **客户端A**: 私网IP `192.168.10.103`，公网IP `119.91.238.117` (通过NAT)
- **客户端B**: 私网IP `192.168.10.102`，公网IP `119.91.238.117` (通过NAT)

### 问题原因

1. 客户端A创建房间，服务器记录其公网IP (119.91.238.117)
2. 客户端B尝试加入，服务器发送客户端A的公网IP给B
3. 客户端B尝试连接到公网IP 119.91.238.117
4. **连接失败** - 因为路由器不支持NAT回环，B无法通过公网IP连接到同一NAT下的A

### 正确做法

当检测到加入方和房主在同一NAT下（公网IP相同）时，服务器应该发送房主的**私网IP**而不是公网IP。

## 解决方案

### 核心逻辑

```
获取加入方的公网IP (从socket连接)
获取房主的公网IP (从房主用户配置)

如果两个公网IP相同：
    发送房主的私网IP给加入方
否则：
    发送房主的公网IP给加入方
```

### 需要修改的文件

**文件**: `src/manager/packetmanager.cpp`

需要修改以下三个函数：
1. `SendHostJoin` - 发送房主信息时
2. `SendRoomPlayerJoin` - 玩家加入房间时
3. 房间用户列表发送函数 - 发送房间内所有玩家信息时

### 示例代码

#### 修改 SendHostJoin 函数

```cpp
void CPacketManager::SendHostJoin(IExtendedSocket* socket, IUser* host)
{
    CSendPacket* msg = CreatePacket(socket, PacketId::Host);
    msg->BuildHeader();

    msg->WriteUInt8(HostPacketType::HostJoin);
    msg->WriteUInt32(host->GetID());
    msg->WriteUInt64(0);

    UserNetworkConfig_s network = host->GetNetworkConfig();

    // 获取加入方的公网IP
    std::string joinerPublicIP = socket->GetIP();
    
    // 获取房主的公网IP
    std::string hostPublicIP = network.m_szExternalIpAddress;
    
    // 判断是否在同一个NAT下
    bool sameNetwork = (joinerPublicIP == hostPublicIP);
    
    // 决定发送哪个IP
    std::string ipToSend = sameNetwork ? network.m_szLocalIpAddress : network.m_szExternalIpAddress;
    
    // 记录日志便于调试
    if (sameNetwork)
    {
        Logger().Info("检测到NAT: 发送私网IP (%s) 给来自同一网络的加入方 (%s)\n",
                     network.m_szLocalIpAddress.c_str(), joinerPublicIP.c_str());
    }

    msg->WriteUInt32(ip_string_to_int(ipToSend), false);
    msg->WriteUInt16(network.m_nExternalClientPort);
    msg->WriteUInt16(network.m_nExternalServerPort);
    msg->WriteUInt32(ip_string_to_int(network.m_szLocalIpAddress), false);
    msg->WriteUInt16(network.m_nLocalClientPort);
    msg->WriteUInt16(network.m_nLocalServerPort);

    socket->Send(msg);
}
```

#### 修改 SendRoomPlayerJoin 函数

```cpp
void CPacketManager::SendRoomPlayerJoin(IExtendedSocket* socket, IUser* user, RoomTeamNum num)
{
    CSendPacket* msg = CreatePacket(socket, PacketId::Room);
    msg->BuildHeader();

    msg->WriteUInt8(OutRoomType::PlayerJoin);
    msg->WriteUInt32(user->GetID());
    msg->WriteUInt32(0);
    msg->WriteString(user->GetUsername());

    UserNetworkConfig_s network = user->GetNetworkConfig();
    
    // 获取接收方的公网IP
    std::string receivingClientIP = socket->GetIP();
    
    // 判断是否在同一网络
    bool sameNetwork = (receivingClientIP == network.m_szExternalIpAddress);
    std::string ipToSend = sameNetwork ? network.m_szLocalIpAddress : network.m_szExternalIpAddress;

    // 用户网络信息
    msg->WriteUInt8(num);
    msg->WriteUInt8(0);
    msg->WriteUInt8(0);
    msg->WriteUInt8(0);
    msg->WriteUInt32(ip_string_to_int(ipToSend), false);
    msg->WriteUInt16(network.m_nExternalClientPort);
    msg->WriteUInt16(network.m_nExternalServerPort);
    msg->WriteUInt32(ip_string_to_int(network.m_szLocalIpAddress), false);
    msg->WriteUInt16(network.m_nLocalClientPort);
    msg->WriteUInt16(network.m_nLocalServerPort);

    CUserCharacter character = user->GetCharacter(UFLAG_LOW_ALL, UFLAG_HIGH_ALL);
    CPacketHelper_FullUserInfo fullUserInfo;
    fullUserInfo.Build(msg->m_OutStream, user->GetID(), character);

    socket->Send(msg);
}
```

#### 修改房间用户列表发送

```cpp
// 在发送房间用户列表的函数中 (约在第2706行)
std::string requestingClientIP = socket->GetIP();

for (auto user : roomInfo->GetUsers())
{
    UserNetworkConfig_s network = user->GetNetworkConfig();
    
    // 判断该用户和请求客户端是否在同一网络
    bool sameNetwork = (requestingClientIP == network.m_szExternalIpAddress);
    std::string ipToSend = sameNetwork ? network.m_szLocalIpAddress : network.m_szExternalIpAddress;
    
    msg->WriteUInt8(user->GetRoomData()->m_Team);
    msg->WriteUInt8(0);
    msg->WriteUInt8(0);
    msg->WriteUInt8(0);
    msg->WriteUInt32(ip_string_to_int(ipToSend), false);
    msg->WriteUInt16(network.m_nExternalClientPort);
    msg->WriteUInt16(network.m_nExternalServerPort);
    msg->WriteUInt32(ip_string_to_int(network.m_szLocalIpAddress), false);
    msg->WriteUInt16(network.m_nLocalClientPort);
    msg->WriteUInt16(network.m_nLocalServerPort);
    // ... 其余代码
}
```

## 辅助函数（可选）

为了避免代码重复，可以创建一个辅助函数：

```cpp
// 添加到 packetmanager.h
std::string GetAppropriateIP(const std::string& targetPublicIP, 
                            const std::string& targetLocalIP, 
                            const std::string& requestingClientIP);

// 添加到 packetmanager.cpp
std::string CPacketManager::GetAppropriateIP(const std::string& targetPublicIP, 
                                            const std::string& targetLocalIP, 
                                            const std::string& requestingClientIP)
{
    // 如果请求客户端和目标用户共享同一个公网IP，说明在同一NAT下
    if (requestingClientIP == targetPublicIP)
    {
        Logger().Debug("检测到同一网络 (%s)，使用本地IP: %s\n", 
                      requestingClientIP.c_str(), targetLocalIP.c_str());
        return targetLocalIP;
    }
    
    // 不同网络 - 返回公网IP
    return targetPublicIP;
}
```

使用方式：
```cpp
std::string ipToSend = GetAppropriateIP(network.m_szExternalIpAddress, 
                                       network.m_szLocalIpAddress, 
                                       socket->GetIP());
```

## 测试步骤

### 测试场景1：同一网络

1. 准备两台在同一局域网的电脑：
   - 电脑A: 192.168.10.103
   - 电脑B: 192.168.10.102
   - NAT路由器公网IP: 119.91.238.117

2. **客户端A** 连接服务器并创建房间
3. **客户端B** 连接服务器
4. **客户端B** 尝试加入客户端A的房间
5. **预期结果**：
   - 服务器日志显示：检测到NAT，发送私网IP
   - 客户端B成功连接到 192.168.10.103
   - 游戏正常开始

### 测试场景2：不同网络

1. **客户端A** (公网IP: 119.91.238.117) 创建房间
2. **客户端C** (公网IP: 185.199.108.153) 尝试加入
3. **预期结果**：
   - 服务器检测到不同的公网IP
   - 发送客户端A的公网IP给客户端C
   - 连接成功（假设端口转发已配置）

### 测试场景3：混合场景

1. **客户端A** 和 **客户端B** 在同一网络
2. **客户端C** 在不同网络
3. **客户端A** 创建房间
4. **预期结果**：
   - 客户端B收到私网IP
   - 客户端C收到公网IP
   - 两者都能成功加入

## 配置要求

无需额外的 ServerConfig.json 配置，但确保：

1. **PublicIP** 已正确设置
2. **现有的P2P连接修复** 已实现 (参见 P2P_CONNECTION_FIX.md)
3. 客户端的私网IP通过holepunch机制正确记录

## 实施检查清单

- [ ] 修改 `SendHostJoin` 函数
- [ ] 修改 `SendRoomPlayerJoin` 函数
- [ ] 修改房间用户列表发送函数
- [ ] 添加调试日志
- [ ] 编译修改后的源代码
- [ ] 替换 CSNZ_Server.exe
- [ ] 测试同一网络场景
- [ ] 测试不同网络场景
- [ ] 测试混合场景
- [ ] 验证服务器日志显示正确的IP选择

## 注意事项

1. **防火墙规则**: 确保UDP端口27005和27015在客户端防火墙上开放
2. **私网IP准确性**: 依赖客户端正确报告其私网IP
3. **VPN连接**: 使用VPN的客户端即使在同一LAN也会有不同的公网IP

## 参考资料

- **源代码仓库**: [JusicP/CSNZ_Server](https://github.com/JusicP/CSNZ_Server)
- **P2P连接修复**: [P2P_CONNECTION_FIX.md](P2P_CONNECTION_FIX.md)
- **详细文档**: [NAT_SAME_NETWORK_FIX.md](NAT_SAME_NETWORK_FIX.md)
